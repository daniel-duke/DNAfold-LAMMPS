import arsenal as ars
import utils
from ovito import scene
from ovito.io import import_file
from ovito.modifiers import ColorCodingModifier
from ovito.modifiers import LoadTrajectoryModifier
from ovito.vis import Viewport, SimulationCellVis
import matplotlib.pyplot as plt
import numpy as np
import pickle
import sys

## Description
# this script reads the first bind times files generated by the dnafold_lmp
  # backend analysis function and writes the geoometry and trajectory files
  # for visualizing the bindtimes.
# the oxdna configuration file has one noteworthy edit; namely, sometimes,
  # oxdna does not place the scaffold strand first when exporting the topology
  # and configuration files from oxView; when this happens, "timestep" of the
  # configuration should be altered to equal the number of bases that need to
  # be skipped before the scaffold strand begins.
# this script will only work if "backend_basics.py" has already been run for
  # the given simulation (requires a populated "analysis" folder).
# there are 4 hyb times results:
  # 1) individual geometry (view with charge): first hyb time 
  # 2) individual trajectory (view with type): hyb status
  # 3) averaged geometry (view with charge): averaged first hyb time
  # 4) averaged rajectory (view with charge): hyb status probability


################################################################################
### Parameters

def main():

	### input files
	simID = "16HB"
	simTag = ""
	srcFold = "/Users/dduke/Files/dnafold_lmp/"
	multiSim = False

	### analysis options
	position_src = "oxdna"			# where to get bead locations (cadnano or oxdna)
	writeHyb = True 				# whether to write hybridization trajectories
	kinetics = True					# whether to run free staple kinetics analysis

	### get simulation folders
	simHomeFold = srcFold + simID + simTag + "/"
	simFolds, nsim = utils.getSimFolds(simHomeFold, multiSim)

	### get pickled data
	connFile = simHomeFold + "analysis/connectivity_vars.pkl"
	ars.testFileExist(connFile,"connectivity")
	with open(connFile,"rb") as f:
		[strands, bonds_backbone, complements, n_scaf] = pickle.load(f)[:4]

	### prepare position data
	r = utils.getIdealPositions(simID, simHomeFold, position_src)
	r, bonds, dbox3 = prepGeoData(r, strands, bonds_backbone)

	### loop over simulations
	hyb_status_allSim = nsim*[None]
	first_hyb_times_allSim = nsim*[None]
	for i in range(nsim):

		### analyze hybridizations
		hybFile = simFolds[i] + "analysis/hyb_status.dat"
		hyb_status_allSim[i], dump_every = utils.readHybStatus(hybFile)
		first_hyb_times_allSim[i], first_hyb_times_scaled = utils.calcFirstHybTimes(hyb_status_allSim[i], complements, n_scaf, dump_every)

		### write hybridization trajectory
		if writeHyb:
			outGeoFile = simFolds[i] + "analysis/hyb_times_geometry.in"
			outDatFile = simFolds[i] + "analysis/hyb_times_trajectory.dat"
			ars.writeGeo(outGeoFile, dbox3, r, charges=first_hyb_times_scaled, bonds=bonds, natomType=2)
			writeAtomDump(outDatFile, dbox3, r, hyb_status_allSim[i]+1, "type", dump_every)

	### averaged binding times
	if multiSim:
		outGeoFile = simHomeFold + "analysis/hyb_times_geometry.in"
		outDatFile = simHomeFold + "analysis/hyb_times_trajectory.dat"
		ovitoFile = simHomeFold + "analysis/vis_hyb_times.ovito"
		hyb_status_avg, first_hyb_times_scaled_avg, nstep_min = averageHybData(hyb_status_allSim, first_hyb_times_allSim, dump_every)
		ars.writeGeo(outGeoFile, dbox3, r, charges=first_hyb_times_scaled_avg, bonds=bonds)
		writeAtomDump(outDatFile, dbox3, r, hyb_status_avg, "charge", dump_every)
		writeOvito(ovitoFile, outGeoFile, outDatFile)

		### kinetics
		if kinetics:
			plotKinetics(strands, hyb_status_allSim, n_scaf, dump_every, nstep_min)
			plt.show()


################################################################################
### Plotters

### plot free staple kinetics
def plotKinetics(strands, hyb_status, n_scaf, dump_every, nstep_min):

	### calculate free staple concentrations
	nsim = len(hyb_status)
	nbead = len(strands)
	nstap = max(strands)-1
	conc_avg = np.zeros(nstep_min)
	conc_sem = np.zeros(nstep_min)
	for i in range(nstep_min):
		stap_freedom = np.ones((nstap,nsim),dtype=int)
		for j in range(n_scaf,nbead):
			for k in range(nsim):
				if hyb_status[k][i,j] == 1:
					stap_freedom[strands[j]-2,k] = 0
		conc_indiv = np.mean(stap_freedom,axis=1)
		conc_avg[i] = np.mean(conc_indiv)
		conc_sem[i] = ars.calcSEM(conc_indiv)

	### calculate time
	dt = 0.01
	scale = 5200
	time = np.arange(nstep_min)*dump_every*dt*scale*1E-9

	### plot
	ars.magicPlot()
	plt.figure("Kinetics",figsize=(8,6))
	plt.plot(time,np.log(conc_avg))
	plt.fill_between(time,np.log(conc_avg-conc_sem),np.log(conc_avg+conc_sem),alpha=0.3)
	plt.xlabel("Simulation Progression")
	plt.ylabel("$\\ln(C/C_0)$")
	plt.title("Free Staple Kinetics")


################################################################################
### File Handlers

### write lammps-style trajectory for stationairy points with changing colors
def writeAtomDump(outDatFile, dbox3, r, colors, colorBy, dump_every):
	print("Writing bind times trajectory...")
	nstep = colors.shape[0]
	npoint = r.shape[0]
	len_npoint = len(str(npoint))
	len_ncolor = len(str(max([max(i) for i in colors])))
	len_dbox3 = len(str(int(max(dbox3)/2)))
	with open(outDatFile,'w') as f:
		for i in range(nstep):
			f.write(f"ITEM: TIMESTEP\n{i}\n")
			f.write(f"ITEM: NUMBER OF ATOMS\n{npoint}\n")
			f.write(f"ITEM: BOX BOUNDS pp pp pp\n")
			f.write(f"-{dbox3[0]/2:0{len_dbox3+3}.2f} {dbox3[0]/2:0{len_dbox3+3}.2f} xlo xhi\n")
			f.write(f"-{dbox3[1]/2:0{len_dbox3+3}.2f} {dbox3[1]/2:0{len_dbox3+3}.2f} ylo yhi\n")
			f.write(f"-{dbox3[2]/2:0{len_dbox3+3}.2f} {dbox3[2]/2:0{len_dbox3+3}.2f} zlo zhi\n")
			f.write(f"ITEM: ATOMS id {colorBy} xs ys zs\n")
			for j in range(npoint):
				f.write(f"{j+1:<{len_npoint}} " + \
						f"{colors[i][j]:<{len_ncolor}}  " + \
						f"{r[j,0]/dbox3[0]+1/2:10.8f} " + \
						f"{r[j,1]/dbox3[1]+1/2:10.8f} " + \
						f"{r[j,2]/dbox3[2]+1/2:10.8f}\n")


### write session state vito file that visualizes the geometry
def writeOvito(ovitoFile, outGeoFile, outDatFile):

	### get base geometry
	pipeline = import_file(outGeoFile, atom_style="full")
	pipeline.add_to_scene()

	### disable simulation cell
	vis_element = pipeline.source.data.cell.vis
	vis_element.enabled = False

	### adjust defaults
	particle_vis = pipeline.source.data.particles.vis
	particle_vis.radius = 1.2
	bonds_vis = pipeline.source.data.particles.bonds.vis
	bonds_vis.width = 2.4

	### set active viewport to top perspective
	viewport = scene.viewports.active_vp
	viewport.type = Viewport.Type.PERSPECTIVE
	viewport.camera_dir = (-1,0,0)
	viewport.camera_up = (0,1,0)
	viewport.zoom_all()

	### load trajectory
	traj_pipeline = import_file(outDatFile, multiple_frames=True)
	traj_mod = LoadTrajectoryModifier()
	traj_mod.source.load(outDatFile)
	pipeline.modifiers.append(traj_mod)

	### add modifiers
	pipeline.modifiers.append(ColorCodingModifier(property='Charge',start_value=0,end_value=1,gradient=ColorCodingModifier.Viridis()))

	### write ovito file
	scene.save(ovitoFile)


################################################################################
### Calculation Managers

### average the first hyb times across several simulations
def averageHybData(hyb_status, first_hyb_times, dump_every):
	nsim = len(first_hyb_times)
	nbead = len(hyb_status[0][0])
	n_scaf = len(first_hyb_times[0])
	nstep_min = min([len(i) for i in hyb_status])
	hyb_status_trim = np.zeros((nsim,nstep_min,nbead))
	first_hyb_times_trim = np.zeros((nsim,n_scaf))
	for i in range(nsim):
		first_hyb_times_trim[i] = first_hyb_times[i][:nstep_min]
		hyb_status_trim[i] = hyb_status[i][:nstep_min]
	hyb_status_avg = np.mean(hyb_status_trim, axis=0)
	first_hyb_times_avg = np.mean(first_hyb_times_trim, axis=0)
	first_hyb_times_scaled_avg = first_hyb_times_avg/nstep_min/dump_every
	return hyb_status_avg, first_hyb_times_scaled_avg, nstep_min


################################################################################
### Utility Functions

### get geometry data ready for visualization
def prepGeoData(r, strands, bonds_backbone):

	### trim to just scaffold data
	n_scaf = np.sum(strands==1)
	r = r[:n_scaf]

	### box diameter
	dbox3 = [ max(abs(r[:,0]))+2.72, max(abs(r[:,1]))+2.4, max(abs(r[:,2]))+2.4 ]
	dbox3 = [ 2*i for i in dbox3 ]

	### get bonds
	bonds = bonds_backbone[bonds_backbone[:,1]<=n_scaf]

	### return results
	return r, bonds, dbox3


### run the script
if __name__ == "__main__":
	main()

