import arsenal as ars
import matplotlib.pyplot as plt
import numpy as np
import pickle
import sys
import utils

## Description
# this script reads the first bind times files generated by the dnafold_lmp
  # backend analysis function and writes the geoometry and trajectory files
  # for visualizing the bindtimes.
# the oxdna configuration file has one noteworthy edit; namely, sometimes,
  # oxdna does not place the scaffold strand first when exporting the topology
  # and configuration files from oxView; when this happens, "timestep" of the
  # configuration should be altered to equal the number of bases that need to
  # be skipped before the scaffold strand begins.
# there are 4 hyb times results:
  # 1) individual geometry (view with charge): first hyb time 
  # 2) individual trajectory (view with type): hyb status
  # 3) averaged geometry (view with charge): averaged first hyb time
  # 4) averaged rajectory (view with charge): hyb status probability

## To Do
# rerun the analysis with correct averaged data, make unbound staples look 
  # like they bind early, write ovito files for visualization


################################################################################
### Parameters

def main():

	### input files
	simID = "16HB"
	simTag = "/resNo"
	srcFold = "/Users/dduke/Files/dnafold_lmp/production/"
	multiSim = True

	### analysis options
	position_src = "oxdna"			# where to get bead locations (cadnano or oxdna)
	writeHyb = True 				# whether to write hybridization trajectories
	kinetics = True					# whether to run free staple kinetics analysis

	### simgle simulation analysis
	if not multiSim:
		nsim = 1
		simFolds = [ srcFold + simID + simTag + "/" ]

	### multiple simulation folders
	else:
		copiesFold = srcFold + simID + simTag + "/"
		copiesFile = copiesFold + "copies.txt"
		copyNames, nsim = ars.readCopies(copiesFile)
		simFolds = [ copiesFold + copyNames[i] + "/" for i in range(nsim) ]

	### get pickled bonds data
	connFile = simFolds[0] + "analysis/connectivity_vars.pkl"
	ars.testFileExist(connFile,"connectivity")
	with open(connFile,"rb") as f:
		[strands, bonds_backbone, complements, n_scaf, circular_scaf] = pickle.load(f)

	### get positions (using cadnano)
	if position_src == "cadnano":
		cadFile = simFolds[0] + simID + ".json"
		r, strands = utils.initPositionsCaDNAno(cadFile)

	### get positions (using oxdna configuration)
	elif position_src == "oxdna":
		cadFile = simFolds[0] + simID + ".json"
		topFile = srcFold + simID + simTag + "/" + simID + ".top"
		confFile = srcFold + simID + simTag + "/" + simID + "_ideal.dat"
		r, strands = utils.initPositionsOxDNA(cadFile, topFile, confFile)

	### prepare the data for nice redering
	r, bonds, dbox3 = prepGeoData(r, strands)

	### loop over simulations
	hyb_status_all = [None]*nsim
	first_hyb_times_all = [None]*nsim
	for i in range(nsim):

		### analyze hybridizations
		hybFile = simFolds[i] + "analysis/hyb_status.dat"
		hyb_status_all[i], dump_every = readHybStatus(hybFile)
		first_hyb_times_all[i], first_hyb_times_scaled = calcFirstHybTimes(hyb_status_all[i], complements, n_scaf, dump_every)


		### write hybridization trajectory
		if writeHyb:
			outGeoFile = simFolds[i] + "analysis/hyb_times_geometry.in"
			outDatFile = simFolds[i] + "analysis/hyb_times_trajectory.dat"
			ars.writeGeo(outGeoFile, dbox3, r, charges=first_hyb_times_scaled, bonds=bonds_backbone[:n_scaf-1+circular_scaf], natomType=2)
			writeAtomDump(outDatFile, dbox3, r, hyb_status_all[i]+1, "type", dump_every)

	### averaged binding times
	if multiSim:
		outGeoFile = copiesFold + "hyb_times_geometry.in"
		outDatFile = copiesFold + "hyb_times_trajectory.dat"
		hyb_status_avg, first_hyb_times_scaled_avg, nstep_min = averageHybData(hyb_status_all, first_hyb_times_all, dump_every)
		ars.writeGeo(outGeoFile, dbox3, r, charges=first_hyb_times_scaled_avg, bonds=bonds_backbone[:n_scaf-1+circular_scaf])
		writeAtomDump(outDatFile, dbox3, r, hyb_status_avg, "charge", dump_every)

		### kinetics
		if kinetics:
			plotKinetics(strands, hyb_status_all, n_scaf, nstep_min, dump_every)
			plt.show()


################################################################################
### Plotters

### plot free staple kinetics
def plotKinetics(strands, hyb_status, n_scaf, nstep_min, dump_every):

	### calculate free staple concentrations
	nsim = len(hyb_status)
	nbead = len(strands)
	nstap = max(strands)-1
	conc_avg = np.zeros(nstep_min)
	conc_sem = np.zeros(nstep_min)
	for i in range(nstep_min):
		stap_freedom = np.ones((nstap,nsim),dtype=int)
		for j in range(n_scaf,nbead):
			for k in range(nsim):
				if hyb_status[k][i,j] == 1:
					stap_freedom[strands[j]-2,k] = 0
		conc_indiv = np.mean(stap_freedom,axis=1)
		conc_avg[i] = np.mean(conc_indiv)
		conc_sem[i] = ars.calcSEM(conc_indiv)

	### calculate time
	dt = 0.01
	scale = 5200
	time = np.arange(nstep_min)*dump_every*dt*scale*1E-9

	### plot
	ars.magicPlot()
	plt.figure("Kinetics",figsize=(8,6))
	plt.plot(time,np.log(conc_avg))
	plt.fill_between(time,np.log(conc_avg-conc_sem),np.log(conc_avg+conc_sem),alpha=0.3)
	plt.xlabel("Simulation Progression")
	plt.ylabel("$\\ln(C/C_0)$")
	plt.title("Free Staple Kinetics")


################################################################################
### File Handlers

### write lammps-style trajectory for stationairy points with changing colors
def writeAtomDump(outDatFile, dbox3, r, colors, colorBy, dump_every):
	print("Writing bind times trajectory...")
	nstep = colors.shape[0]
	npoint = r.shape[0]
	len_npoint = len(str(npoint))
	len_ncolor = len(str(max([max(i) for i in colors])))
	len_dbox3 = len(str(int(max(dbox3)/2)))
	with open(outDatFile,'w') as f:
		for i in range(nstep):
			f.write(f"ITEM: TIMESTEP\n{i}\n")
			f.write(f"ITEM: NUMBER OF ATOMS\n{npoint}\n")
			f.write(f"ITEM: BOX BOUNDS pp pp pp\n")
			f.write(f"-{dbox3[0]/2:0{len_dbox3+3}.2f} {dbox3[0]/2:0{len_dbox3+3}.2f} xlo xhi\n")
			f.write(f"-{dbox3[1]/2:0{len_dbox3+3}.2f} {dbox3[1]/2:0{len_dbox3+3}.2f} ylo yhi\n")
			f.write(f"-{dbox3[2]/2:0{len_dbox3+3}.2f} {dbox3[2]/2:0{len_dbox3+3}.2f} zlo zhi\n")
			f.write(f"ITEM: ATOMS id {colorBy} xs ys zs\n")
			for j in range(npoint):
				f.write(f"{j+1:<{len_npoint}} " + \
						f"{colors[i][j]:<{len_ncolor}}  " + \
						f"{r[j,0]/dbox3[0]+1/2:10.8f} " + \
						f"{r[j,1]/dbox3[1]+1/2:10.8f} " + \
						f"{r[j,2]/dbox3[2]+1/2:10.8f}\n")


### read hybridization times file
def readHybStatus(inHybFile):
	ars.testFileExist(inHybFile,"hybridization status")
	with open(inHybFile, 'r') as f:
		content = f.readlines()

	### extract metadata
	nbead = 0
	while ars.isnumber(content[nbead+1].split()[0]):
		nbead += 1
	nstep = int(len(content)/(nbead+1))
	dump_every = int(content[nbead+1].split()[1])

	### read data
	hyb_status = np.zeros((nstep,nbead),dtype=int)
	for i in range(nstep):
		for j in range(nbead):
			hyb_status[i,j] = int(content[i*(nbead+1)+j+1].split()[1])

	### return results
	return hyb_status, dump_every


################################################################################
### Calculation Managers

### get first bind times (scaled by total simulation time) from hybridization status
def calcFirstHybTimes(hyb_status, complements, n_scaf, dump_every):
	nstep = hyb_status.shape[0]
	first_hyb_times = np.zeros(n_scaf)
	for i in range(n_scaf):
		if len(complements[i]) > 0:
			first_hyb_times[i] = nstep*dump_every
	for i in range(nstep):
		for j in range(n_scaf):
			if hyb_status[i,j] == 1:
				first_hyb_times[j] = min([first_hyb_times[j],i*dump_every])
	return first_hyb_times, first_hyb_times/nstep/dump_every


### average the first hyb times across several simulations
def averageHybData(hyb_status, first_hyb_times, dump_every):
	nsim = len(first_hyb_times)
	nbead = len(hyb_status[0][0])
	n_scaf = len(first_hyb_times[0])
	nstep_min = min([len(i) for i in hyb_status])
	hyb_status_trim = np.zeros((nsim,nstep_min,nbead))
	first_hyb_times_trim = np.zeros((nsim,n_scaf))
	for i in range(nsim):
		first_hyb_times_trim[i] = first_hyb_times[i][:nstep_min]
		hyb_status_trim[i] = hyb_status[i][:nstep_min]
	hyb_status_avg = np.mean(hyb_status_trim, axis=0)
	first_hyb_times_avg = np.mean(first_hyb_times_trim, axis=0)
	first_hyb_times_scaled_avg = first_hyb_times_avg/nstep_min/dump_every
	return hyb_status_avg, first_hyb_times_scaled_avg, nstep_min


################################################################################
### Utility Functions

### positions and strands to 
def prepGeoData(r, strands):

	### trim to just scaffold data
	n_scaf = strands.count(1)
	r = r[:n_scaf]

	### box diameter
	dbox3 = [ max(abs(r[:,0]))+2.72, max(abs(r[:,1]))+2.4, max(abs(r[:,2]))+2.4 ]
	dbox3 = [ 2*i for i in dbox3 ]

	### get bonds
	bonds = np.zeros((0,3),dtype=int)
	for bi in range(n_scaf-1):
		bonds = np.append(bonds,[[strands[bi],bi+1,bi+2]],axis=0)

	### return results
	return r, bonds, dbox3


### run the script
if __name__ == "__main__":
	main()

